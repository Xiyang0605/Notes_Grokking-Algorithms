#Chapter 1 Introduction to algorithms
- Binary search only works when your list is in sorted order.
- Algorithm speed isn't measured in seconds.
- Algorith times are measured in terms of growth of an algorithm - O(n): Linear Time; O(logn) Logarithmic Time.
- Big O notation lets ppl compare the number of operations, instead of seconds, ms -- it tells how fast the algorithm grows in the worst secnario.
- O(logn) is faster than O(n), but it gets a lot faster as the list of items grows.


#Chapter 2 Selection Sort
- When you want to store multiple elements, use an array or a list.
- With an array, all your elements are stored right next to each other
- With a list, elements are strewn all over, and one element stores the address of the next one
- Array allow fast reads
- Linked lists allow fast inserts and deletes
- All elements in the array should be the same type




#Chapter 3 Recursion
- Recursion is when a function calls itself.
- Every recursive function has two cases: base case, and the recursive base.
- A stack has two operations:push and pop.
- All function calls go onto the call stack.
- The call stack can get large, which takes a lot of memory - some may choose loops, but it's not that elegant/clear to understand for developers.

#Chapter 4 Quicksort
- D&C wokrs by breaking a problem down into smaller and smaller pieces.
- If implementing quicksort, choose a random element as the pivot, the average runtime of quicksort is O(nlogn).
- The constant in Big O notation matter sometimes, that's why quicksort is faster than merge sort.
- The constant almost never matters for simple search versus binary search, because O(log n) is so much faster than O(n) when the list is big.


#Chapter 5 Hashtables
- Once your load factor is greater than .07, it's time to resize hash table
- Hash tables are used for caching data
- Hash tables are great for catching dubplicates


#Chapter 6 Breadth first search
- It tells you if there is a path from A to B
- If there's a path, breadth-first search will find the shortest path
- If having a problem like 'Find the shortest X', try modeling the problem as a graph and use breadth first search to solve
- A directed graph has arrows and the relationship follows the direction of the arrow
- Undirected graph don't have arrows, and the relationship follows the direction of the arrow
- Queues are FIFO
- Stacks are LIFO
- Once you check someone, make sure you don't check them again, otherwise, might end up in an infinite loop

#Chapter 7 Dijkstra's algorithm
- Breadth-first search is used to calculate the shortest path for an unweighted graph.
- Dijkstra's algorithm is used to calculate the shortest path for a weighted graph.
- Dijsktra's algorithm works when all the weights are positive.
- If you have negative weights, use The Bellman-Ford algorithm.

#Chapter 9 Dynamic programming
- Dynamic programming is useful when you are trying to optimize something given a constraint.
- You can use dynamic programming when the problem can be broken into discrete subproblems
- Every dynamic programming solution involves a grid
- The values in the cells are usually what you are trying to optimize
- Each cell is a subporblem, so think about how you can divide your problem into subproblems
- There is no single formula for calculating a dynamic programming solution
- Question: What's the difference between longest common substring and longest common subsequence?

#Chapter 10 Introduction to machine learning
-  KNN is used for classification and regression and involves looking at the k-nearest neighbors (example: For N users, look at Sqrt(N) neighbors at least)
- Classification=categorization into a group
- Regression=predicting a response
- Feature extraction means converting an item into a list of numbers that can be compared.
- Picking good features is important part of a successful KNN algorithm.
