#Chapter 1 Introduction to algorithms
- Binary search only works when your list is in sorted order.
- Algorithm speed isn't measured in seconds.
- Algorith times are measured in terms of growth of an algorithm - O(n): Linear Time; O(logn) Logarithmic Time.
- Big O notation lets ppl compare the number of operations, instead of seconds, ms -- it tells how fast the algorithm grows in the worst secnario.
- O(logn) is faster than O(n), but it gets a lot faster as the list of items grows.


#Chapter 2 Selection Sort
- When you want to store multiple elements, use an array or a list.
- With an array, all your elements are stored right next to each other
- With a list, elements are strewn all over, and one element stores the address of the next one
- Array allow fast reads
- Linked lists allow fast inserts and deletes
- All elements in the array should be the same type




#Chapter 3 Recursion
- Recursion is when a function calls itself.
- Every recursive function has two cases: base case, and the recursive base.
- A stack has two operations:push and pop.
- All function calls go onto the call stack.
- The call stack can get large, which takes a lot of memory - some may choose loops, but it's not that elegant/clear to understand for developers.

#Chapter 4 Quicksort
- D&C wokrs by breaking a problem down into smaller and smaller pieces.
- If implementing quicksort, choose a random element as the pivot, the average runtime of quicksort is O(nlogn).
- The constant in Big O notation matter sometimes, that's why quicksort is faster than merge sort.
- The constant almost never matters for simple search versus binary search, because O(log n) is so much faster than O(n) when the list is big.


#Chapter 5 Hashtables
- Once your load factor is greater than .07, it's time to resize hash table
- Hash tables are used for caching data
- Hash tables are great for catching dubplicates


#Chapter 6 Breadth first search
- It tells you if there is a path from A to B
- If there's a path, breadth-first search will find the shortest path
- If having a problem like 'Find the shortest X', try modeling the problem as a graph and use breadth first search to solve
- A directed graph has arrows and the relationship follows the direction of the arrow
- Undirected graph don't have arrows, and the relationship follows the direction of the arrow
- Queues are FIFO
- Stacks are LIFO
- Once you check someone, make sure you don't check them again, otherwise, might end up in an infinite loop
